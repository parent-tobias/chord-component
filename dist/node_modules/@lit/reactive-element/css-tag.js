/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const S = globalThis, n = S.ShadowRoot && (S.ShadyCSS === void 0 || S.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, l = Symbol(), c = /* @__PURE__ */ new WeakMap();
class a {
  constructor(s, e, o) {
    if (this._$cssResult$ = !0, o !== l) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = s, this.t = e;
  }
  get styleSheet() {
    let s = this.o;
    const e = this.t;
    if (n && s === void 0) {
      const o = e !== void 0 && e.length === 1;
      o && (s = c.get(e)), s === void 0 && ((this.o = s = new CSSStyleSheet()).replaceSync(this.cssText), o && c.set(e, s));
    }
    return s;
  }
  toString() {
    return this.cssText;
  }
}
const r = (t) => new a(typeof t == "string" ? t : t + "", void 0, l), h = (t, s) => {
  if (n) t.adoptedStyleSheets = s.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of s) {
    const o = document.createElement("style"), i = S.litNonce;
    i !== void 0 && o.setAttribute("nonce", i), o.textContent = e.cssText, t.appendChild(o);
  }
}, d = n ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((s) => {
  let e = "";
  for (const o of s.cssRules) e += o.cssText;
  return r(e);
})(t) : t;
export {
  a as CSSResult,
  h as adoptStyles,
  d as getCompatibleStyle,
  n as supportsAdoptingStyleSheets,
  r as unsafeCSS
};
